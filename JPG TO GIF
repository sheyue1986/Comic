<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>逐幀動畫生成器</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- GIF.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&display=swap');

        body {
            /* 優先使用等線，後備微軟雅黑 */
            font-family: 'DengXian', 'Microsoft YaHei', 'PingFang TC', sans-serif;
            background-color: #1a1a1a; /* 深灰背景 */
            color: #d1d1d1;
        }

        /* 新中式風格組件 (New Chinese Style) */
        .ncs-card {
            background-color: #262626;
            border: 1px solid #444;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .ncs-input {
            background-color: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 8px 12px;
            width: 100%;
            border-radius: 2px;
            transition: all 0.3s ease;
            outline: none;
        }
        .ncs-input:focus {
            border-color: #b8860b; /* 暗金色 */
            background-color: #3a3a3a;
        }

        .ncs-btn {
            border: 1px solid #b8860b;
            color: #b8860b;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            background: transparent;
            letter-spacing: 1px;
        }
        .ncs-btn:hover:not(:disabled) {
            background-color: #b8860b;
            color: #000;
        }
        .ncs-btn:disabled {
            border-color: #555;
            color: #555;
            cursor: not-allowed;
        }
        
        .ncs-btn-danger {
            border-color: #aa381e;
            color: #aa381e;
        }
        .ncs-btn-danger:hover {
            background-color: #aa381e;
            color: white;
        }
        
        .ncs-btn-active {
            background-color: #b8860b;
            color: #000;
        }

        .ncs-header-accent {
            border-left: 3px solid #aa381e; /* 硃砂紅 */
            padding-left: 10px;
            color: #eee;
            font-weight: bold;
            letter-spacing: 1px;
        }
        
        /* Checkbox Style */
        .ncs-checkbox {
            appearance: none;
            background-color: #333;
            border: 1px solid #555;
            width: 16px;
            height: 16px;
            cursor: pointer;
            position: relative;
        }
        .ncs-checkbox:checked {
            background-color: #b8860b;
            border-color: #b8860b;
        }
        .ncs-checkbox:checked::after {
            content: '✓';
            position: absolute;
            top: -4px;
            left: 1px;
            color: black;
            font-size: 12px;
            font-weight: bold;
        }

        /* 網格覆蓋層邏輯 */
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }
        .grid-line-x {
            position: absolute;
            left: 0;
            right: 0;
            border-top: 1px solid rgba(184, 134, 11, 0.6); /* 暗金線條 */
        }
        .grid-line-y {
            position: absolute;
            top: 0;
            bottom: 0;
            border-left: 1px solid rgba(184, 134, 11, 0.6);
        }

        /* 滾動條美化 */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        /* 裝飾性紋理 */
        .bg-pattern {
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23333333' fill-opacity='0.1'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
        }
        
        /* Frame Delete Button */
        .delete-btn {
            opacity: 0;
            transition: opacity 0.2s;
        }
        .frame-container:hover .delete-btn {
            opacity: 1;
        }
        
        .cursor-crosshair-custom {
            cursor: crosshair !important;
        }
    </style>
</head>
<body class="bg-pattern min-h-screen">
    <div id="root"></div>

    <!-- React Dependencies -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- INLINE ICON COMPONENTS ---
        const IconBase = ({ size = 20, className = "", children, ...props }) => (
            <svg 
                xmlns="http://www.w3.org/2000/svg" 
                width={size} 
                height={size} 
                viewBox="0 0 24 24" 
                fill="none" 
                stroke="currentColor" 
                strokeWidth="1.5" 
                strokeLinecap="round" 
                strokeLinejoin="round" 
                className={className} 
                {...props}
            >
                {children}
            </svg>
        );

        const Upload = (props) => (
            <IconBase {...props}>
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/>
            </IconBase>
        );

        const Download = (props) => (
            <IconBase {...props}>
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/>
            </IconBase>
        );

        const ImageIcon = (props) => (
            <IconBase {...props}>
                <rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/>
            </IconBase>
        );

        const SettingsIcon = (props) => (
            <IconBase {...props}>
                <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/>
            </IconBase>
        );

        const Film = (props) => (
            <IconBase {...props}>
                <rect width="18" height="18" x="3" y="3" rx="2"/><path d="M7 3v18"/><path d="M3 7.5h4"/><path d="M3 12h18"/><path d="M3 16.5h4"/><path d="M17 3v18"/><path d="M17 7.5h4"/><path d="M17 16.5h4"/>
            </IconBase>
        );

        const XIcon = (props) => (
            <IconBase {...props}>
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </IconBase>
        );

        const VideoIcon = (props) => (
            <IconBase {...props}>
                <polygon points="23 7 16 12 23 17 23 7"></polygon>
                <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
            </IconBase>
        );
        
        const PipetteIcon = (props) => (
            <IconBase {...props}>
                <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z" />
            </IconBase>
        );

        // Fetch the worker script code as a Blob URL
        const getWorkerBlob = async () => {
            try {
                const response = await fetch('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js');
                const text = await response.text();
                const blob = new Blob([text], { type: 'application/javascript' });
                return URL.createObjectURL(blob);
            } catch (e) {
                console.error("Failed to fetch worker", e);
                return 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js';
            }
        };

        const App = () => {
            // File & Mode State
            const [fileSrc, setFileSrc] = useState(null);
            const [fileType, setFileType] = useState('image'); // 'image' | 'video'
            const [fileName, setFileName] = useState("請選擇圖片或視頻...");
            
            // Image Mode Settings
            const [rows, setRows] = useState(4);
            const [cols, setCols] = useState(4);
            const [offsets, setOffsets] = useState({ top: 0, bottom: 0, left: 0, right: 0 });

            // Video Mode Settings
            const [videoFps, setVideoFps] = useState(5); // Frames per second extraction
            
            // General Settings
            const [delay, setDelay] = useState(150);
            const [removeBg, setRemoveBg] = useState(false); // Auto remove background
            const [isTransparent, setIsTransparent] = useState(true); // GIF transparency
            
            // Eyedropper State
            const [targetColor, setTargetColor] = useState(null); // {r, g, b}
            const [isPicking, setIsPicking] = useState(false);
            const [tolerance, setTolerance] = useState(30);

            // Output State
            const [extractedFrames, setExtractedFrames] = useState([]);
            const [generatedGif, setGeneratedGif] = useState(null);
            const [isGenerating, setIsGenerating] = useState(false);
            const [status, setStatus] = useState("");

            // Refs
            const imgRef = useRef(null);
            const videoRef = useRef(null);
            const workerUrlRef = useRef(null);
            const isManualEditRef = useRef(false);

            // Cleanup
            useEffect(() => {
                return () => {
                    if (workerUrlRef.current) URL.revokeObjectURL(workerUrlRef.current);
                };
            }, []);

            // Handle Upload
            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    setFileName(file.name);
                    const isVideo = file.type.startsWith('video');
                    setFileType(isVideo ? 'video' : 'image');
                    setGeneratedGif(null);
                    setExtractedFrames([]);
                    isManualEditRef.current = false;
                    setTargetColor(null); // Reset target color on new upload

                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        setFileSrc(evt.target.result);
                    };
                    reader.readAsDataURL(file);
                }
            };

            const updateOffset = (key, value) => {
                const val = parseInt(value) || 0;
                setOffsets(prev => ({ ...prev, [key]: val }));
                isManualEditRef.current = false;
            };

            // Helper: Remove Background (Chroma Key)
            const removeBackgroundColor = (ctx, width, height) => {
                const frameData = ctx.getImageData(0, 0, width, height);
                const data = frameData.data;
                
                let r0, g0, b0;

                if (targetColor) {
                    // Use picked color
                    r0 = targetColor.r;
                    g0 = targetColor.g;
                    b0 = targetColor.b;
                } else {
                    // Default to top-left pixel
                    r0 = data[0];
                    g0 = data[1];
                    b0 = data[2];
                }

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i], g = data[i + 1], b = data[i + 2];
                    // Simple Euclidean distance for color difference
                    // Can be improved with LAB color space but simple diff works for sprites
                    const diff = Math.abs(r - r0) + Math.abs(g - g0) + Math.abs(b - b0);
                    
                    if (diff < tolerance * 3) {
                        data[i + 3] = 0; // Set Alpha to 0
                    }
                }
                ctx.putImageData(frameData, 0, 0);
            };
            
            // Handle Preview Click for Eyedropper
            const handlePreviewClick = (e) => {
                if (!isPicking || !fileSrc) return;

                const element = fileType === 'image' ? imgRef.current : videoRef.current;
                if (!element) return;

                // Create a temporary canvas to draw the element and pick color
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Get click coordinates relative to the element
                const rect = element.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Calculate scaling factors (display size vs natural size)
                const displayWidth = rect.width;
                const displayHeight = rect.height;
                const naturalWidth = fileType === 'image' ? element.naturalWidth : element.videoWidth;
                const naturalHeight = fileType === 'image' ? element.naturalHeight : element.videoHeight;
                
                const scaleX = naturalWidth / displayWidth;
                const scaleY = naturalHeight / displayHeight;
                
                const actualX = Math.floor(x * scaleX);
                const actualY = Math.floor(y * scaleY);
                
                // Draw only the 1x1 pixel we need (efficient)
                canvas.width = 1;
                canvas.height = 1;
                
                // Draw relative to the source position
                // drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
                ctx.drawImage(element, actualX, actualY, 1, 1, 0, 0, 1, 1);
                
                const p = ctx.getImageData(0, 0, 1, 1).data;
                setTargetColor({ r: p[0], g: p[1], b: p[2] });
                setIsPicking(false); // Stop picking
                isManualEditRef.current = false; // Trigger re-extraction
            };

            // --- IMAGE EXTRACTION LOGIC ---
            useEffect(() => {
                if (fileType === 'image' && fileSrc && imgRef.current && !isManualEditRef.current) {
                    const timer = setTimeout(extractImageFrames, 100);
                    return () => clearTimeout(timer);
                }
            }, [fileSrc, rows, cols, offsets, fileType, removeBg, targetColor, tolerance]);

            const extractImageFrames = () => {
                const img = imgRef.current;
                if (!img || img.naturalWidth === 0) return;

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                const totalWidth = img.naturalWidth;
                const totalHeight = img.naturalHeight;
                const cellWidth = Math.floor(totalWidth / cols);
                const cellHeight = Math.floor(totalHeight / rows);
                const finalWidth = cellWidth - offsets.left - offsets.right;
                const finalHeight = cellHeight - offsets.top - offsets.bottom;

                if (finalWidth <= 0 || finalHeight <= 0) return;

                canvas.width = finalWidth;
                canvas.height = finalHeight;

                const frames = [];

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        ctx.clearRect(0, 0, finalWidth, finalHeight);
                        const sx = (c * cellWidth) + offsets.left;
                        const sy = (r * cellHeight) + offsets.top;
                        ctx.drawImage(img, sx, sy, finalWidth, finalHeight, 0, 0, finalWidth, finalHeight);
                        
                        if (removeBg) {
                            removeBackgroundColor(ctx, finalWidth, finalHeight);
                        }

                        frames.push(canvas.toDataURL('image/png'));
                    }
                }
                setExtractedFrames(frames);
            };

            // --- VIDEO EXTRACTION LOGIC ---
            useEffect(() => {
                if (fileType === 'video' && fileSrc && !isManualEditRef.current && extractedFrames.length > 0) {
                     // Trigger re-extraction if coloring settings change
                     extractVideoFrames();
                }
            }, [removeBg, targetColor, tolerance]);

            const extractVideoFrames = async () => {
                const video = videoRef.current;
                if (!video) return;

                setStatus("正在處理視頻...");
                setIsGenerating(true);
                
                const duration = video.duration;
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                const frames = [];
                const interval = 1 / videoFps;
                
                let currentTime = 0;
                isManualEditRef.current = false;

                const seekAndCapture = async () => {
                    while (currentTime < duration) {
                        video.currentTime = currentTime;
                        await new Promise(resolve => {
                            const onSeek = () => {
                                video.removeEventListener('seeked', onSeek);
                                resolve();
                            };
                            video.addEventListener('seeked', onSeek);
                        });
                        
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        
                        if (removeBg) {
                            removeBackgroundColor(ctx, canvas.width, canvas.height);
                        }

                        frames.push(canvas.toDataURL('image/png'));
                        
                        currentTime += interval;
                        setStatus(`提取進度: ${Math.round((currentTime/duration)*100)}%`);
                    }
                    setExtractedFrames(frames);
                    setIsGenerating(false);
                    setStatus("提取完成");
                };

                seekAndCapture();
            };

            const onVideoLoaded = () => {
                extractVideoFrames();
            };

            // --- DELETE FRAME ---
            const handleDeleteFrame = (indexToDelete) => {
                isManualEditRef.current = true;
                setExtractedFrames(prev => prev.filter((_, idx) => idx !== indexToDelete));
            };

            // --- GIF GENERATION ---
            const generateGIF = async () => {
                if (extractedFrames.length === 0) return;
                
                setIsGenerating(true);
                setStatus("初始化 GIF 引擎...");

                try {
                    if (!workerUrlRef.current) {
                        workerUrlRef.current = await getWorkerBlob();
                    }
                    
                    const tempImg = await new Promise(resolve => {
                        const i = new Image();
                        i.onload = () => resolve(i);
                        i.src = extractedFrames[0];
                    });

                    const gif = new GIF({
                        workers: 2,
                        quality: 10,
                        width: tempImg.width,
                        height: tempImg.height,
                        workerScript: workerUrlRef.current,
                        transparent: isTransparent ? 'rgba(0,0,0,0)' : null
                    });

                    setStatus("添加幀...");
                    
                    const loadFrame = (src) => {
                        return new Promise((resolve) => {
                            const img = new Image();
                            img.onload = () => resolve(img);
                            img.src = src;
                        });
                    };

                    for (const frameSrc of extractedFrames) {
                        const imgEl = await loadFrame(frameSrc);
                        gif.addFrame(imgEl, { delay: delay, copy: true });
                    }

                    gif.on('finished', (blob) => {
                        setGeneratedGif(URL.createObjectURL(blob));
                        setIsGenerating(false);
                        setStatus("完成！");
                    });
                    
                    gif.on('progress', (p) => {
                        setStatus(`渲染中: ${Math.round(p * 100)}%`);
                    });

                    setStatus("渲染中...");
                    gif.render();

                } catch (err) {
                    console.error(err);
                    setStatus("錯誤！");
                    setIsGenerating(false);
                }
            };

            const renderGridLines = () => {
                if (!rows || !cols) return null;
                const lines = [];
                for (let i = 1; i < rows; i++) {
                    lines.push(<div key={`h-${i}`} className="grid-line-x" style={{ top: `${(i / rows) * 100}%` }} />);
                }
                for (let i = 1; i < cols; i++) {
                    lines.push(<div key={`v-${i}`} className="grid-line-y" style={{ left: `${(i / cols) * 100}%` }} />);
                }
                return lines;
            };

            return (
                <div className="min-h-screen p-4 md:p-8 flex flex-col items-center pb-20 font-[DengXian]">
                    
                    {/* --- TITLE --- */}
                    <div className="w-full max-w-6xl mb-8 flex flex-col items-center gap-2">
                        <div className="text-3xl md:text-4xl font-light tracking-[0.2em] text-[#d4af37]">
                            逐幀動畫生成器
                        </div>
                        <div className="text-xs text-gray-500 tracking-widest uppercase">
                            SPRITE / VIDEO TO GIF
                        </div>
                        <div className="w-16 h-[1px] bg-[#aa381e] mt-2"></div>
                    </div>

                    <div className="w-full max-w-6xl grid grid-cols-1 lg:grid-cols-12 gap-6">
                        
                        {/* --- LEFT COLUMN: CONTROLS --- */}
                        <div className="lg:col-span-4 flex flex-col gap-5">
                            
                            {/* Upload Card */}
                            <div className="ncs-card p-5">
                                <div className="ncs-header-accent mb-4 text-sm">媒體上傳</div>
                                <div className="relative group">
                                    <input 
                                        type="file" 
                                        accept="image/*,video/mp4,video/webm" 
                                        onChange={handleFileUpload}
                                        className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10"
                                    />
                                    <div className="border border-dashed border-gray-600 bg-[#333] p-4 flex items-center justify-between rounded hover:border-[#b8860b] transition-colors">
                                        <span className="text-sm text-gray-400 truncate pr-2 max-w-[150px]">{fileName}</span>
                                        {fileType === 'video' ? <VideoIcon size={18} className="text-gray-400" /> : <Upload size={18} className="text-gray-400" />}
                                    </div>
                                </div>
                                <div className="text-[10px] text-gray-500 mt-2 text-right">支持 JPG, PNG, MP4</div>
                            </div>

                            {/* Settings Card */}
                            <div className="ncs-card p-5">
                                <div className="flex items-center gap-2 mb-6 border-b border-[#444] pb-2">
                                    <SettingsIcon size={18} className="text-[#b8860b]" />
                                    <span className="ncs-header-accent border-none p-0 text-[#d1d1d1]">參數設置</span>
                                </div>

                                <div className="space-y-5">
                                    {/* MODE SPECIFIC SETTINGS */}
                                    {fileType === 'image' ? (
                                        <React.Fragment>
                                            <div className="grid grid-cols-2 gap-4">
                                                <div>
                                                    <label className="block text-xs text-gray-500 mb-1">行數 (Rows)</label>
                                                    <input type="number" min="1" value={rows} onChange={(e) => { isManualEditRef.current = false; setRows(Math.max(1, Number(e.target.value))); }} className="ncs-input" />
                                                </div>
                                                <div>
                                                    <label className="block text-xs text-gray-500 mb-1">列數 (Cols)</label>
                                                    <input type="number" min="1" value={cols} onChange={(e) => { isManualEditRef.current = false; setCols(Math.max(1, Number(e.target.value))); }} className="ncs-input" />
                                                </div>
                                            </div>
                                            {/* Offsets */}
                                            <div className="pt-2 border-t border-[#444] border-dashed">
                                                <div className="text-xs text-[#b8860b] mb-2 tracking-wider">邊距修剪 (PX)</div>
                                                <div className="grid grid-cols-2 gap-3">
                                                    <div><label className="block text-[10px] text-gray-500 text-center">上 (TOP)</label><input type="number" value={offsets.top} onChange={(e) => updateOffset('top', e.target.value)} className="ncs-input text-center text-xs p-1" /></div>
                                                    <div><label className="block text-[10px] text-gray-500 text-center">下 (BTM)</label><input type="number" value={offsets.bottom} onChange={(e) => updateOffset('bottom', e.target.value)} className="ncs-input text-center text-xs p-1" /></div>
                                                    <div><label className="block text-[10px] text-gray-500 text-center">左 (LFT)</label><input type="number" value={offsets.left} onChange={(e) => updateOffset('left', e.target.value)} className="ncs-input text-center text-xs p-1" /></div>
                                                    <div><label className="block text-[10px] text-gray-500 text-center">右 (RGT)</label><input type="number" value={offsets.right} onChange={(e) => updateOffset('right', e.target.value)} className="ncs-input text-center text-xs p-1" /></div>
                                                </div>
                                            </div>
                                        </React.Fragment>
                                    ) : (
                                        /* VIDEO SETTINGS */
                                        <div>
                                            <label className="block text-xs text-gray-500 mb-1 flex justify-between">
                                                <span>視頻提取幀率 (FPS)</span>
                                                <span className="text-[#b8860b]">{videoFps}</span>
                                            </label>
                                            <div className="flex items-center gap-2">
                                                <input 
                                                    type="range" min="1" max="30" step="1" 
                                                    value={videoFps} 
                                                    onChange={(e) => { isManualEditRef.current = false; setVideoFps(Number(e.target.value)); }}
                                                    className="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:w-4 [&::-webkit-slider-thumb]:h-4 [&::-webkit-slider-thumb]:rounded-full [&::-webkit-slider-thumb]:bg-[#b8860b]"
                                                />
                                            </div>
                                            <div className="text-[10px] text-gray-500 mt-1">
                                                * 數值越高，提取的圖片越多，生成速度越慢
                                            </div>
                                            <button onClick={extractVideoFrames} className="mt-2 text-xs border border-gray-600 px-2 py-1 hover:bg-[#333] text-gray-400">
                                                重新提取視頻幀
                                            </button>
                                        </div>
                                    )}

                                    {/* COMMON SETTINGS */}
                                    <div className="pt-4 border-t border-[#444]">
                                        <label className="block text-xs text-gray-500 mb-1 flex justify-between">
                                            <span>GIF 幀延遲 (速度)</span>
                                            <span className="text-[#b8860b]">{delay} ms</span>
                                        </label>
                                        <input 
                                            type="range" min="20" max="500" step="10" 
                                            value={delay} 
                                            onChange={(e) => setDelay(Number(e.target.value))}
                                            className="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:w-4 [&::-webkit-slider-thumb]:h-4 [&::-webkit-slider-thumb]:rounded-full [&::-webkit-slider-thumb]:bg-[#b8860b]"
                                        />
                                    </div>
                                    
                                    {/* Auto Remove Background Toggle */}
                                    <div className="flex flex-col gap-2 pt-2 border-t border-[#444]">
                                        <div className="flex items-center gap-2">
                                            <input 
                                                type="checkbox" 
                                                id="remove-bg-check"
                                                checked={removeBg} 
                                                onChange={(e) => setRemoveBg(e.target.checked)}
                                                className="ncs-checkbox"
                                            />
                                            <label htmlFor="remove-bg-check" className="text-xs text-gray-400 select-none cursor-pointer hover:text-white transition-colors">
                                                自動去除背景顏色
                                            </label>
                                        </div>
                                        
                                        {removeBg && (
                                            <div className="pl-6 space-y-3 animate-fade-in">
                                                {/* Eyedropper Button */}
                                                <div className="flex items-center gap-2">
                                                    <button 
                                                        onClick={() => setIsPicking(!isPicking)}
                                                        className={`text-xs px-2 py-1 border border-gray-600 rounded flex items-center gap-2 ${isPicking ? 'bg-[#b8860b] text-black border-[#b8860b]' : 'text-gray-400 hover:bg-[#333]'}`}
                                                    >
                                                        <span className="text-lg">⌖</span>
                                                        {isPicking ? '請點擊預覽圖...' : '吸管工具 (選擇顏色)'}
                                                    </button>
                                                    {targetColor && (
                                                        <div 
                                                            className="w-6 h-6 rounded border border-gray-500"
                                                            style={{ backgroundColor: `rgb(${targetColor.r}, ${targetColor.g}, ${targetColor.b})` }}
                                                            title={`RGB(${targetColor.r}, ${targetColor.g}, ${targetColor.b})`}
                                                        ></div>
                                                    )}
                                                </div>
                                                
                                                {/* Tolerance Slider */}
                                                <div>
                                                    <label className="block text-[10px] text-gray-500 mb-1 flex justify-between">
                                                        <span>容差 (Tolerance)</span>
                                                        <span className="text-[#b8860b]">{tolerance}</span>
                                                    </label>
                                                    <input 
                                                        type="range" min="1" max="100" step="1"
                                                        value={tolerance} 
                                                        onChange={(e) => { isManualEditRef.current = false; setTolerance(Number(e.target.value)); }}
                                                        className="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:w-3 [&::-webkit-slider-thumb]:h-3 [&::-webkit-slider-thumb]:rounded-full [&::-webkit-slider-thumb]:bg-[#b8860b]"
                                                    />
                                                </div>
                                                <div className="text-[9px] text-gray-500">
                                                    * 如果默認左上角顏色不對，請使用吸管點擊預覽圖中的背景色。
                                                </div>
                                            </div>
                                        )}
                                    </div>

                                    {/* Transparent GIF Toggle */}
                                     <div className="flex items-center gap-2 pt-2">
                                        <input 
                                            type="checkbox" 
                                            id="transparent-gif-check"
                                            checked={isTransparent} 
                                            onChange={(e) => setIsTransparent(e.target.checked)}
                                            className="ncs-checkbox"
                                        />
                                        <label htmlFor="transparent-gif-check" className="text-xs text-gray-400 select-none cursor-pointer hover:text-white transition-colors">
                                            GIF 保留透明通道
                                        </label>
                                    </div>

                                </div>
                            </div>

                            {/* Action Button */}
                            <button 
                                onClick={generateGIF}
                                disabled={!fileSrc || isGenerating || extractedFrames.length === 0}
                                className={`ncs-btn py-4 w-full flex items-center justify-center gap-2 ${(!fileSrc || isGenerating) ? 'opacity-50' : ''}`}
                            >
                                {isGenerating ? (
                                    <React.Fragment>
                                        <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-[#b8860b]"></div>
                                        <span>處理中...</span>
                                    </React.Fragment>
                                ) : (
                                    <React.Fragment>
                                        <Film size={20} />
                                        <span>生成 GIF</span>
                                    </React.Fragment>
                                )}
                            </button>
                            
                            {status && (
                                <div className="text-center text-xs text-gray-500 font-mono mt-1">
                                    [ 系統狀態: {status} ]
                                </div>
                            )}
                        </div>

                        {/* --- RIGHT COLUMN: PREVIEW --- */}
                        <div className="lg:col-span-8 flex flex-col gap-6">
                            
                            {/* Preview Area (Image or Video) */}
                            <div className="ncs-card bg-[#222] overflow-hidden min-h-[300px] flex flex-col">
                                <div className="bg-[#1f1f1f] px-4 py-3 border-b border-[#333] flex justify-between items-center">
                                    <span className="text-sm tracking-wide text-gray-300">
                                        {fileType === 'image' ? '圖片網格預覽' : '視頻源預覽'}
                                        {isPicking && <span className="ml-2 text-[#b8860b] animate-pulse"> - 請點擊畫面選擇背景色</span>}
                                    </span>
                                    <span className="text-xs text-gray-600">PREVIEW</span>
                                </div>
                                
                                <div 
                                    className={`flex-1 p-4 flex justify-center items-center overflow-auto relative bg-[#1a1a1a] ${isPicking ? 'cursor-crosshair-custom' : ''}`}
                                    onClick={handlePreviewClick}
                                >
                                    {fileSrc ? (
                                        fileType === 'image' ? (
                                            <div className={`relative inline-block border border-gray-700 shadow-xl ${isPicking ? 'pointer-events-none' : ''}`}>
                                                <img 
                                                    ref={imgRef} 
                                                    src={fileSrc} 
                                                    alt="Sprite Sheet" 
                                                    onLoad={() => { if(!isManualEditRef.current) extractImageFrames() }}
                                                    className="max-w-full max-h-[500px] block" 
                                                />
                                                <div className="grid-overlay">{!isPicking && renderGridLines()}</div>
                                            </div>
                                        ) : (
                                            <div className={`relative w-full flex justify-center ${isPicking ? 'pointer-events-none' : ''}`}>
                                                <video 
                                                    ref={videoRef} 
                                                    src={fileSrc} 
                                                    controls={!isPicking}
                                                    onLoadedMetadata={onVideoLoaded}
                                                    className="max-h-[500px] max-w-full border border-gray-700"
                                                />
                                            </div>
                                        )
                                    ) : (
                                        <div className="text-gray-600 flex flex-col items-center gap-2">
                                            <ImageIcon size={48} strokeWidth={1} />
                                            <span className="text-sm font-light">暫無媒體</span>
                                        </div>
                                    )}
                                </div>
                            </div>

                            {/* Extracted Frames List (With Delete) */}
                            {extractedFrames.length > 0 && (
                                <div className="ncs-card p-4">
                                    <div className="mb-4 flex justify-between items-center border-l-2 border-[#b8860b] pl-2">
                                        <div className="text-xs text-[#b8860b]">
                                            提取幀預覽 ({extractedFrames.length}) 
                                            <span className="text-gray-500 ml-2 font-normal">- 可點擊紅色 X 刪除不需要的幀</span>
                                        </div>
                                    </div>
                                    
                                    <div className="flex gap-2 overflow-x-auto pb-2 scrollbar-thin">
                                        {extractedFrames.map((frame, idx) => (
                                            <div key={idx} className="frame-container flex-shrink-0 w-20 h-20 bg-[#333] border border-[#444] flex items-center justify-center relative rounded-sm group hover:border-[#aa381e] transition-colors bg-[url('https://media.istockphoto.com/id/1303646736/vector/transparent-pattern-background-simulation-alpha-channel-png-seamless-gray-and-white.jpg?s=612x612&w=0&k=20&c=6h4hNn8BwH_w9W2J0yv_VfA1WX7P5x5X_5_5_5_5')] bg-contain">
                                                <img src={frame} alt={`F${idx}`} className="max-w-full max-h-full p-1 relative z-10" />
                                                <span className="absolute bottom-0 left-0 bg-black/70 text-white text-[9px] px-1 pointer-events-none z-20">{idx+1}</span>
                                                
                                                {/* Delete Button */}
                                                <button 
                                                    onClick={() => handleDeleteFrame(idx)}
                                                    className="delete-btn absolute -top-2 -right-2 bg-[#aa381e] text-white rounded-full p-0.5 shadow-md hover:scale-110 transition-transform z-30"
                                                    title="刪除此幀"
                                                >
                                                    <XIcon size={12} />
                                                </button>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {/* Result Area */}
                            {generatedGif && (
                                <div className="ncs-card p-6 border-[#b8860b] bg-[#1f1f1f]">
                                    <div className="flex flex-col md:flex-row gap-8 items-center justify-center">
                                        <div className="relative group">
                                            <div className="absolute -inset-1 bg-gradient-to-r from-[#b8860b] to-[#aa381e] opacity-20 blur group-hover:opacity-40 transition duration-1000"></div>
                                            {/* Checkerboard background for transparency check */}
                                            <div className="relative bg-[url('https://media.istockphoto.com/id/1303646736/vector/transparent-pattern-background-simulation-alpha-channel-png-seamless-gray-and-white.jpg?s=612x612&w=0&k=20&c=6h4hNn8BwH_w9W2J0yv_VfA1WX7P5x5X_5_5_5_5')] bg-contain p-1 border border-[#555]">
                                                <img src={generatedGif} alt="Final GIF" className="max-w-full max-h-[250px] min-w-[100px] min-h-[100px] object-contain" />
                                            </div>
                                        </div>
                                        
                                        <div className="flex flex-col gap-3">
                                            <div className="text-lg text-gray-200 font-light mb-2 text-center md:text-left">
                                                生成完成
                                            </div>
                                            <a 
                                                href={generatedGif} 
                                                download={`sprite_gif_${Date.now()}.gif`}
                                                className="ncs-btn px-8 py-3 flex items-center gap-2 bg-[#b8860b] text-black hover:bg-[#d4af37] border-none"
                                            >
                                                <Download size={18} />
                                                <span>立即下載</span>
                                            </a>
                                            <div className="text-[10px] text-gray-500 text-center">
                                                右鍵亦可另存圖片
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}

                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
